<style>
pre.example {
border: 1px solid #aaa;
border-radius: 3px;
background: #eee;
margin-left: 20px;
padding: 5px;
overflow: auto;
}
p.indent {
margin-left: 20px;
}
</style>
<p>
Dans la mission
<a href="http://www.checkio.org/mission/find-friends/share/3061fec1b35588e4bae8ad69db073aab/">
"How to find friends" ("Comment trouver des amis")
</a>, il sera agréable de disposer d'une structure de données adaptée au problème. 
Dans notre mission, nous allons construire une structure de données 
adaptée au stockage et au travail sur un réseau d'amis.
</p>
<p>
La classe "Friends" devra contenir les noms des amis, et les liens entre eux.    
Les noms seront représentés par des chaînes de caractères, et seront sensibles à la casse (minuscule / majuscule).   
Les liens entre amis sont non orientés, ce qui signifie que si "sophia" est liée à "nikola", 
alors réciproquement "nikola" est lié à "sophia".
</p>
<p>
<em>class</em> <strong>Friends</strong><em>(connections)</em>
</p>
<p class="indent">
Rnvoie une nouvelle instance de Friens.    
<em>"connections"</em> est un itérable d'ensembles (set) contenant deux éléments chacun.
Chaque connexion contient deux noms (chaîne de caractères).
Les connexions peuvent répétées dans les données initiales, mais elles ne sont stockées qu'une fois dans la classe.
Chaque connexion a exactement deux états : existe ou non.
</p>
<pre class="example">
>>> Friends(({"a", "b"}, {"b", "c"}, {"c", "a"}, {"a", "c"}))
>>> Friends([{"1", "2"}, {"3", "1"}])
</pre>
<br>
<p>
<strong>add</strong>(connection)
</p>
<p class="indent">
Ajoute une connexion dans l'instance.    
 <em>"connection"</em> est un ensemble de deux noms (str).
Renvoie True si la connexion est nouvelle.
Renvoie False si la connexion existait déjà.
</p>
<pre class="example">
>>> f = Friends([{"1", "2"}, {"3", "1"}])
>>> f.add({"1", "3"})
False
>>> f.add({"4", "5"})
True
</pre>
<br>
<p>
<strong>remove</strong>(connection)
</p>
<p class="indent">
Enlève une connexion de l'instance.
<em>"connection"</em> 
est un ensemble de deux noms (str).
Renvoie True si la connexion existait.
Renvoie False si cette connexion n'est pas dans l'instance.
</p>
<pre class="example">
>>> f = Friends([{"1", "2"}, {"3", "1"}])
>>> f.remove({"1", "3"})
True
>>> f.remove({"4", "5"})
False
</pre>
<br>
<p>
<strong>names</strong>()
</p>
<p class="indent">
Renvoie un ensemble (set) de noms (str).
L'ensemble contient uniquement les noms qui sont connectés à quelqu'un.
</p>
<pre class="example">
>>> f = Friends(({"a", "b"}, {"b", "c"}, {"c", "d"}))
>>> f.names()
{"a", "b", "c", "d"}
>>> f.remove({"d", "c"})
True
>>> f.names()
{"a", "b", "c"}
</pre>
<br>
<p>
<strong>connected</strong>(name)
</p>
<p class="indent">
Renvoie un ensemble de noms qui sont connectés avec le  <em>"name"</em> (nom) donné.
Si "name" n'existe pas dans l'instance, renvoie alors l'ensemble vide.
</p>
<pre class="example">
>>> f = Friends(({"a", "b"}, {"b", "c"}, {"c", "a"}))
>>> f.connected("a")
{"b", "c"}
>>> f.connected("d")
set()
>>> f.remove({"c", "a"})
True
>>> f.connected("c")
{"b"}
>>> f.remove({"c", "b"})
True
>>> f.connected("c")
set()
</pre>
<br>
<p>
Dans cette mission, toutes les données sont correctes, 
et il sera inutile d'implémenter une vérification de conformité des données.    
</p>
<p>
<strong>Input: </strong> 
Déclarations et expressions avec la classe Friends.
</p>
<p>
<strong>Output: </strong> Le comportement tel qu'il est décrit.
</p>
<p class="for_info_only">
<strong>Utilisation: </strong>
Vous allez implémenter ici une classe avec des états qui évoluent (mutables).
Il s'agit de représentation "objet" d'une structure complexe.

</p>
<p>
<strong>Précondition:</strong>
Toutes les données sont correctes.
</p>
